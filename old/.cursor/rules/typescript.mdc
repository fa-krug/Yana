---
description: TypeScript best practices and conventions
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: false
---

# TypeScript Best Practices

## Type Safety

### Enable Strict Mode

Always use strict TypeScript configuration:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true
  }
}
```

### Avoid `any` Type

**Never use `any`**. Use `unknown` when the type is truly unknown:

```typescript
// ❌ Bad
function processData(data: any) {
  return data.value;
}

// ✅ Good
function processData(data: unknown) {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return (data as { value: unknown }).value;
  }
  throw new Error('Invalid data');
}

// ✅ Better - Use type guards
function isDataWithValue(data: unknown): data is { value: unknown } {
  return typeof data === 'object' && data !== null && 'value' in data;
}

function processData(data: unknown) {
  if (isDataWithValue(data)) {
    return data.value; // TypeScript knows data has 'value'
  }
  throw new Error('Invalid data');
}
```

### Use Union and Intersection Types

Leverage TypeScript's type system for better type safety:

```typescript
// ✅ Union types for multiple possibilities
type Status = 'pending' | 'approved' | 'rejected';

type ApiResponse<T> = 
  | { status: 'success'; data: T }
  | { status: 'error'; error: string };

// ✅ Intersection types for composition
type User = {
  id: string;
  name: string;
};

type Admin = User & {
  permissions: string[];
  role: 'admin';
};
```

### Explicit Return Types

Always specify return types for functions:

```typescript
// ❌ Bad
function calculateTotal(price: number, tax: number) {
  return price + tax;
}

// ✅ Good
function calculateTotal(price: number, tax: number): number {
  return price + tax;
}

// ✅ Good - Complex return types
async function fetchUser(id: string): Promise<User | null> {
  // ...
}
```

## Null and Undefined Handling

### Use Optional Chaining and Nullish Coalescing

```typescript
// ❌ Bad
const name = user && user.profile && user.profile.name || 'Guest';

// ✅ Good
const name = user?.profile?.name ?? 'Guest';

// ✅ Good - With default values
const count = items?.length ?? 0;
const title = article?.title || 'Untitled';
```

### Handle Nullable Types Explicitly

```typescript
// ✅ Good - Explicit nullable types
function getUser(id: string): User | null {
  // ...
}

// ✅ Good - Optional parameters
function createUser(name: string, email?: string): User {
  // ...
}

// ✅ Good - Required fields with defaults
interface Config {
  apiUrl: string;
  timeout: number;
  retries?: number; // Optional
}
```

## Type Definitions

### Use `readonly` for Immutability

```typescript
// ✅ Good
interface User {
  readonly id: string;
  readonly createdAt: Date;
  name: string; // Mutable
}

// ✅ Good - Readonly arrays
const items: readonly string[] = ['a', 'b', 'c'];
// items.push('d'); // ❌ Error

// ✅ Good - Readonly utility type
type ReadonlyUser = Readonly<User>;
```

### Prefer Interfaces for Objects, Types for Unions/Intersections

```typescript
// ✅ Good - Interface for object shape
interface User {
  id: string;
  name: string;
  email: string;
}

// ✅ Good - Type for unions/intersections
type Status = 'active' | 'inactive' | 'pending';
type AdminUser = User & { role: 'admin' };

// ✅ Good - Type for complex types
type EventHandler = (event: Event) => void;
```

### Use `const` Assertions for Literal Types

```typescript
// ❌ Bad
const Status = {
  Pending: 'pending',
  Approved: 'approved',
  Rejected: 'rejected'
};

// ✅ Good
const Status = {
  Pending: 'pending',
  Approved: 'approved',
  Rejected: 'rejected'
} as const;

type Status = typeof Status[keyof typeof Status]; // 'pending' | 'approved' | 'rejected'
```

## Type Guards

### Implement Custom Type Guards

```typescript
// ✅ Good - Type guard function
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'name' in obj &&
    typeof (obj as User).id === 'string' &&
    typeof (obj as User).name === 'string'
  );
}

// Usage
const data: unknown = getData();
if (isUser(data)) {
  console.log(data.name); // TypeScript knows data is User
}
```

## Generics

### Use Generics for Reusable Code

```typescript
// ✅ Good - Generic function
function identity<T>(value: T): T {
  return value;
}

// ✅ Good - Generic interface
interface Repository<T> {
  findById(id: string): Promise<T | null>;
  save(entity: T): Promise<T>;
  delete(id: string): Promise<void>;
}

// ✅ Good - Constrained generics
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}
```

## Enums vs Const Objects

### Prefer Const Objects Over Enums

```typescript
// ❌ Avoid enums (unless needed for reverse mapping)
enum Status {
  Pending = 'pending',
  Approved = 'approved',
  Rejected = 'rejected'
}

// ✅ Good - Const object with type
const Status = {
  Pending: 'pending',
  Approved: 'approved',
  Rejected: 'rejected'
} as const;

type Status = typeof Status[keyof typeof Status];
```

## Error Handling

### Use Result Types Instead of Throwing

```typescript
// ✅ Good - Result type pattern
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

async function fetchData(): Promise<Result<User, string>> {
  try {
    const user = await api.getUser();
    return { success: true, data: user };
  } catch (error) {
    return { success: false, error: error.message };
  }
}
```

## Code Organization

### Use Path Aliases

```typescript
// ✅ Good - Use path aliases from tsconfig.json
import { UserService } from '@app/core/services/user.service';
import { Feed } from '@server/db/types';

// ❌ Bad - Relative paths
import { UserService } from '../../../core/services/user.service';
```

### Export Types Explicitly

```typescript
// ✅ Good - Explicit type exports
export type { User, Feed, Article } from './types';
export type { ApiResponse, ApiError } from './api';

// ✅ Good - Re-export with type keyword
export type { User as UserType } from './user';
```

## Best Practices Summary

1. ✅ **Always use strict mode**
2. ✅ **Never use `any` - use `unknown` instead**
3. ✅ **Specify explicit return types**
4. ✅ **Use optional chaining (`?.`) and nullish coalescing (`??`)**
5. ✅ **Prefer `readonly` for immutable data**
6. ✅ **Use type guards for type narrowing**
7. ✅ **Leverage union and intersection types**
8. ✅ **Use generics for reusable code**
9. ✅ **Prefer const objects over enums**
10. ✅ **Use path aliases for imports**
