---
description: Creating and modifying aggregator plugins (TypeScript)
globs: ["src/server/aggregators/**/*.ts"]
alwaysApply: false
---

# Aggregator Plugin System (TypeScript)

## Overview

The aggregator system uses the **Template Method Pattern** to enforce a fixed, consistent flow across all aggregators. All aggregators follow the same flow, with the ability to override specific steps as needed.

**For detailed flow documentation, see:** [docs/AGGREGATOR_FLOW.md](../../docs/AGGREGATOR_FLOW.md)

## Quick Start

Create `src/server/aggregators/my_site.ts`:

```typescript
import { BaseAggregator } from "./base/aggregator";
import type { RawArticle } from "./base/types";
import { fetchFeed } from "./base/fetch";
import Parser from "rss-parser";

export class MySiteAggregator extends BaseAggregator {
  override readonly id = "my_site";
  override readonly type = "managed" as const;
  override readonly name = "My Site";
  override readonly url = "https://example.com/feed.xml";
  override readonly description = "Full-text articles from My Site";

  // OPTIONAL: CSS selectors for elements to remove
  override readonly selectorsToRemove = [
    "nav", "footer", ".advertisement", ".social-share"
  ];

  // OPTIONAL: Wait for this element before extracting content
  override readonly waitForSelector = ".article-content";

  // OPTIONAL: Playwright timeout in milliseconds
  override readonly fetchTimeout = 30000;

  // REQUIRED: Implement fetchSourceData
  protected override async fetchSourceData(
    limit?: number,
  ): Promise<Parser.Output<any>> {
    if (!this.feed) throw new Error("Feed not initialized");
    return await fetchFeed(this.feed.identifier);
  }

  // REQUIRED: Implement parseToRawArticles
  protected override async parseToRawArticles(
    sourceData: unknown,
  ): Promise<RawArticle[]> {
    const feed = sourceData as Parser.Output<any>;
    return (feed.items || []).map((item) => ({
      title: item.title || "",
      url: item.link || "",
      published: item.pubDate ? new Date(item.pubDate) : new Date(),
      summary: item.contentSnippet || "",
    }));
  }
}
```

Then register it in `src/server/aggregators/registry.ts`:

```typescript
import { MySiteAggregator } from "./my_site";

const aggregatorClasses = new Map<string, new () => BaseAggregator>([
  // ... existing aggregators
  ["my_site", MySiteAggregator],
]);
```

## Aggregator Types

### Managed Aggregators
- Pre-configured URL in class
- One-click enable in admin
- Example: `heise.ts`, `tagesschau.ts`

### Custom Aggregators
- User provides feed URL
- Generic content extraction
- Example: `full_website.ts`

### Social Aggregators
- Use identifier instead of URL (e.g., subreddit name, YouTube channel)
- May use external APIs
- Example: `reddit.ts`, `youtube.ts`

## Fixed Aggregation Flow

All aggregators follow this fixed flow (Template Method Pattern):

1. `initialize()` - Initialize aggregator (called by service)
2. `validate()` - Validate feed identifier/configuration
3. `fetchSourceData()` - Fetch RSS/API data
   - `applyRateLimiting()` - Rate limit API requests (optional)
4. `parseToRawArticles()` - Transform source data to RawArticle[]
   - `extractMetadata()` - Extract metadata (optional)
5. `filterArticles()` - Apply skip logic, filters, limits
   - `shouldSkipArticle()` - Check if article should be skipped
   - `applyArticleFilters()` - Apply title/content filters
   - `applyArticleLimit()` - Apply daily/aggregation limits
6. `enrichArticles()` - Fetch content, extract, process (per article)
   - `shouldFetchContent()` - Check if content needs fetching
   - `getCachedContent()` - Check cache (optional)
   - `fetchArticleContent()` - Fetch HTML/content (fail-fast)
   - `extractContent()` - Extract main content
     - `removeElementsBySelectors()` - Remove unwanted elements
   - `validateContent()` - Validate content quality (skip if invalid)
   - `processContent()` - Sanitize, transform, standardize
   - `extractImages()` - Extract images (optional)
   - `setCachedContent()` - Cache processed content (optional)
7. `collectFeedIcon()` - Collect feed icon (optional, called by service)
8. `finalizeArticles()` - Final validation, deduplication, sorting (optional)

**See [docs/AGGREGATOR_FLOW.md](../../docs/AGGREGATOR_FLOW.md) for detailed step-by-step breakdown.**

## Common Customizations

### Skip Unwanted Articles

```typescript
protected override shouldSkipArticle(article: RawArticle): boolean {
  if (super.shouldSkipArticle(article)) return true;

  const skipTerms = ["[SPONSORED]", "Advertisement", "heise+"];
  if (skipTerms.some(term => article.title.includes(term))) {
    this.logger.debug(
      {
        step: "filterArticles",
        subStep: "shouldSkipArticle",
        aggregator: this.id,
        feedId: this.feed?.id,
        reason: "filtered",
        title: article.title,
      },
      "Skipping filtered article",
    );
    return true;
  }

  return false;
}
```

### Custom Content Extraction

```typescript
protected override async extractContent(
  html: string,
  article: RawArticle,
): Promise<string> {
  const { extractContent } = await import("./base/extract");

  // Extract from specific container
  const extracted = extractContent(html, {
    contentSelector: "article.post-content, .story-body",
    selectorsToRemove: this.selectorsToRemove,
  });

  // Use base removeElementsBySelectors for additional cleanup
  return await super.removeElementsBySelectors(extracted, article);
}
```

### Configuration Options

```typescript
override readonly options = {
  max_comments: {
    type: "integer" as const,
    label: "Maximum comments",
    helpText: "Number of comments to extract (0 to disable)",
    default: 0,
    min: 0,
    max: 100,
  },
  traverse_multipage: {
    type: "boolean" as const,
    label: "Traverse multi-page articles",
    default: false,
  },
};

// Access options at runtime
protected override async processContent(
  html: string,
  article: RawArticle,
): Promise<string> {
  const maxComments = this.getOption("max_comments", 0) as number;
  if (maxComments > 0) {
    // Extract comments...
  }
  return await super.processContent(html, article);
}
```

### Custom Rate Limiting

```typescript
readonly rateLimitDelay: number = 2000; // 2 seconds

protected override async applyRateLimiting(): Promise<void> {
  // Custom rate limiting logic
  await super.applyRateLimiting();
}
```

### Custom Caching

```typescript
readonly cacheTTL: number = 7200; // 2 hours
readonly cacheMaxSize: number = 500; // 500 entries
```

## API-Based Aggregators

Some aggregators use external APIs instead of RSS feeds. Examples:

### YouTube Aggregator (`youtube.ts`)

Uses YouTube Data API v3 to fetch videos from channels:

```typescript
export class YouTubeAggregator extends BaseAggregator {
  override readonly id = "youtube";
  override readonly type = "social" as const; // Uses identifier instead of URL
  override readonly name = "YouTube Channel";

  // Override fetchSourceData to use API instead
  protected override async fetchSourceData(
    limit?: number,
  ): Promise<unknown> {
    const apiKey = await this.getApiKey(); // Requires YouTube API key
    const channelId = await resolveChannelId(this.feed!.identifier, apiKey);
    // ... API calls to channels.list, playlistItems.list, videos.list
    return { videos, channelId };
  }

  // Override parseToRawArticles to convert API response
  protected override async parseToRawArticles(
    sourceData: unknown,
  ): Promise<RawArticle[]> {
    const { videos } = sourceData as { videos: YouTubeVideo[] };
    return videos.map((video) => ({
      title: video.snippet.title,
      url: `https://www.youtube.com/watch?v=${video.id}`,
      // ... convert to RawArticle format
    }));
  }
}
```

**Key differences from RSS-based aggregators:**
- Uses `type = "social"` (identifier-based, not URL-based)
- Overrides `fetchSourceData()` to make API calls
- Overrides `parseToRawArticles()` to convert API responses to RawArticle[]
- Requires API credentials in user settings
- No web scraping or RSS parsing needed

**Pattern for API-based aggregators:**
1. Override `validate()` to resolve identifier (e.g., channel ID from handle)
2. Override `fetchSourceData()` to make API calls
3. Override `parseToRawArticles()` to convert API responses to RawArticle[]
4. Override `applyRateLimiting()` if needed for API rate limits
5. Rest of the pipeline (filterArticles, enrichArticles) works the same

See `src/server/aggregators/youtube.ts` and `src/server/aggregators/reddit.ts` for complete examples.

## Debugging Tools

### Test Aggregator Script

Test all aggregators against a specific URL:

```bash
npm run test:aggregator <url>
```

This helps with:
- Testing aggregator changes
- Debugging content extraction issues
- Comparing aggregator behavior on the same URL
- Quick validation during development

## Reference Files

- `src/server/aggregators/base/aggregator.ts` - BaseAggregator class (Template Method Pattern)
- `src/server/aggregators/full_website.ts` - Simple generic RSS aggregator
- `src/server/aggregators/heise.ts` - Complex example with comments extraction
- `src/server/aggregators/youtube.ts` - API-based aggregator (YouTube Data API v3)
- `src/server/aggregators/reddit.ts` - API-based aggregator (Reddit JSON API)
- `docs/AGGREGATOR_FLOW.md` - Comprehensive flow documentation
